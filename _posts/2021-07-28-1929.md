---
title:  "[프로그래머스] 다음 큰 숫자"
excerpt: ""
last_modified_at: '2021-07-28 19:29:00 +0900'
categories:
    - PS
tags:
    - 프로그래머스
    - Python
mathjax: false
---

## 문제

[출처](https://programmers.co.kr/learn/courses/30/lessons/12911)

## 이해

### 입력 

* 자연수 ```n```
    * 범위: [1, 100만]
            
### 출력 

* 조건을 만족하는 수 x

### 조건

1. x는 n보다 큰 자연수이다.
2. x와 n을 2진수로 나타낼 때, 1의 개수는 같다.
3. x는 1과 2를 모두 만족하는 수 중 가장 작은 수이다.

### 예시

#### 입출력

```
입력: 
78

출력: 
83
```

## 접근

### brute-force

문제에서 주어진 조건 그대로 n보다 큰 모든 자연수를 오름차순으로 조회하여, 2진법으로 표현했을 때 ```1```의 개수를 세서, 만족하는 첫 번째 수를 return한다.

```python
def solution(n):
    cnt = bin(n).count('1')
    answer = n + 1
    while bin(answer).count('1') != cnt:
        answer += 1
    return answer
```

### ???

여기서 멈추면 아쉽기 때문에 더 어려운 풀이를 생각해보았다.

우선 가장 간단한 케이스부터 생각을 해보자.

```
1 -> 10
11 -> 101
111 -> 1011
1111 -> 10111
```

```1...``` 패턴은 쉽게 이해할 수 있다. 예를 들어 ```111``` 을 생각해보자. ```111``` 에 대한 답은 ```1xxx``` 꼴이 된다. 3개의 1bit 중 한 개는 이미 사용하였으므로 남은 2개의 1bit를 가장 낮은 자리에 배치하면 답은 ```1011```이 된다.

그런데 이 논리는 ```1...0...``` 과 같은 패턴에도 적용할 수 있다. 예를 들어 자리수가 같으면서 ```1100``` 보다 큰 수는 ```1101, 1110, 1111``` 인데 세 가지 모두 1bit의 수가 ```1100``` 보다 많기 때문에 정답에서 제외된다. 따라서 답은 ```1xxxx``` 꼴이 되는데 남은 1개의 1bit를 가장 낮은 자리에 배치하면 답은 ```10001```이 된다.

그리고 계속하여 일반적인 패턴으로 확장시킬 수 있다. 예를 들어 ```11010110``` 는 ```11010000 + 110``` 으로 생각할 수 있다. 이때 ```110``` 에 대한 답은 ```1001``` 이 된다. ```11010000 + 1001``` 에서는 carry가 발생하지 않으므로 1bit의 수가 그대로 유지된다.

즉, 임의의 수에서 ```"01"``` 을 찾아서 두 부분으로 분리하면 뒷 부분은 항상 ```1...0...``` 패턴이 되어서 자리수가 1개 많아진 답을 구할 수 있고, 이를 앞 부분과 결합시키면 전체의 답이 된다는 것이다. 단, ```"01"``` 은 여러 위치에 존재할 수 있는데 그 중 가장 낮은 자리를 선택해야 한다. 분리한 ```"01"``` 은 항상 ```"10"``` 으로 바뀌기 때문에 낮은 자리를 선택할 수록 작아진다. 이에 대한 극단적인 예로 ```1010101```을 생각해볼 수 있다. 이는 ```1010100 + 1```로 분리할 수 있고 ```1``` 의 답은 ```10```이기 때문에 ```1010100 + 10 = 1010110``` 이 답이 된다.

## 구현

```python
def solution(n):
    # b가 '1...0...' 패턴일 때 답을 return
    def get(b):
        one = b.count('1')
        return '1' + '0'*(len(b)-one+1) + '1'*(one-1)
    
    answer = 0
    b = bin(n)[2:]
    
    # 가장 오른쪽에 위치한 '01'을 찾는다.
    check = ''.join(reversed(b)).find('10')
    
    # 없으면 전체가 '1...0...' 패턴
    if check == -1:
        answer = int(get(b), 2)
    else:
        check = -(check + 2)
        # '01'이 있으면 전체를 두 부분으로 쪼개서 해결
        answer = int(b[:check]+get(b[check+1:]), 2)
        
    return answer
```